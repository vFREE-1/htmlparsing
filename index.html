<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>高容错 Markdown 解析器</title>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@11.9.0/styles/github.min.css">
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
      line-height: 1.6;
      color: #333;
      background-color: #f6f8fa;
      padding: 20px;
      max-width: 900px;
      margin: 0 auto;
    }
    .markdown-container {
      background: #fff;
      padding: 40px;
      border-radius: 8px;
      box-shadow: 0 1px 3px rgba(0,0,0,0.1);
      margin-bottom: 20px;
    }
    .error {
      color: #dc3545;
      background: #f8d7da;
      padding: 20px;
      border-radius: 8px;
      margin-bottom: 20px;
    }
    .debug-info {
      background: #f1f3f5;
      padding: 15px;
      border-radius: 6px;
      font-size: 12px;
      color: #666;
      margin-top: 10px;
      overflow-x: auto;
    }
    /* Markdown 基础样式 */
    .markdown-container h1, .markdown-container h2, .markdown-container h3 {
      margin: 24px 0 16px;
      font-weight: 600;
      line-height: 1.25;
      border-bottom: 1px solid #eaecef;
      padding-bottom: 0.3em;
    }
    .markdown-container h1 { font-size: 2em; }
    .markdown-container h2 { font-size: 1.5em; }
    .markdown-container h3 { font-size: 1.25em; border-bottom: none; }
    .markdown-container p { margin: 16px 0; }
    .markdown-container pre {
      background: #f6f8fa;
      padding: 16px;
      border-radius: 6px;
      overflow: auto;
      margin: 16px 0;
    }
    .markdown-container code {
      font-family: SFMono-Regular, Consolas, "Liberation Mono", Menlo, monospace;
      font-size: 0.875em;
      padding: 0.2em 0.4em;
      margin: 0;
      background-color: rgba(27,31,35,0.05);
      border-radius: 3px;
    }
    .markdown-container pre code { padding: 0; background: none; }
    .markdown-container ul, .markdown-container ol {
      padding-left: 2em;
      margin: 16px 0;
    }
    .markdown-container li { margin: 4px 0; }
    .markdown-container a { color: #0366d6; text-decoration: none; }
    .markdown-container a:hover { text-decoration: underline; }
    .markdown-container blockquote {
      margin: 16px 0;
      padding: 0 1em;
      color: #6a737d;
      border-left: 4px solid #dfe2e5;
    }
    .markdown-container img {
      max-width: 100%;
      border-radius: 6px;
      margin: 16px 0;
    }
    /* 响应式适配 */
    @media (max-width: 768px) {
      body { padding: 10px; }
      .markdown-container { padding: 20px; }
    }
  </style>
</head>
<body>
  <div id="markdownContent" class="markdown-container"></div>
  <div id="debugInfo" class="debug-info" style="display: none;"></div>

  <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/highlight.js@11.9.0/lib/highlight.min.js"></script>

  <script>
    // 配置marked解析器
    marked.setOptions({
      highlight: function(code, lang) {
        if (lang && hljs.getLanguage(lang)) {
          try { return hljs.highlight(code, { language: lang }).value; } 
          catch (err) { console.error('代码高亮失败:', err); }
        }
        try { return hljs.highlightAuto(code).value; } 
        catch (err) { console.error('自动高亮失败:', err); }
        return code;
      },
      breaks: true, gfm: true, headerIds: false
    });

    // 获取URL参数
    function getQueryParam(name) {
      return new URLSearchParams(window.location.search).get(name) || '';
    }

    /**
     * 增强版Base64解码（高容错）
     * @param {string} encodedStr - 原始Base64编码串
     * @returns {string} 解码后的文本
     * @throws {Error} 解码失败时抛出详细错误
     */
    function decodeSafeBase64(encodedStr) {
      if (!encodedStr) throw new Error('Base64编码字符串为空');
      
      // 步骤1：预处理 - 过滤非法字符，只保留Base64合法字符（含URL安全变体）
      const cleanStr = encodedStr.replace(/[^A-Za-z0-9+/=_-]/g, '');
      if (cleanStr.length === 0) throw new Error('过滤后无有效Base64字符');

      // 步骤2：URL安全Base64转换（-→+，_→/）
      let standardStr = cleanStr.replace(/-/g, '+').replace(/_/g, '/');

      // 步骤3：智能补全Padding（=）- 处理长度不是4的倍数的情况
      const paddingLen = (4 - (standardStr.length % 4)) % 4;
      standardStr += '='.repeat(paddingLen);

      // 步骤4：多级解码重试（兼容不同字符集）
      let decodedText = '';
      const decodeMethods = [
        // 方法1：标准atob + UTF-8解码（推荐）
        () => {
          const binaryStr = atob(standardStr);
          const uint8Array = new Uint8Array(binaryStr.length);
          for (let i = 0; i < binaryStr.length; i++) {
            uint8Array[i] = binaryStr.charCodeAt(i);
          }
          return new TextDecoder('utf-8', { fatal: true }).decode(uint8Array);
        },
        // 方法2：降级方案（兼容旧版浏览器/特殊字符）
        () => decodeURIComponent(escape(atob(standardStr))),
        // 方法3：忽略编码错误的降级方案
        () => {
          const binaryStr = atob(standardStr);
          return binaryStr.split('').map(c => c.charCodeAt(0) < 128 ? c : '?').join('');
        }
      ];

      for (let i = 0; i < decodeMethods.length; i++) {
        try {
          decodedText = decodeMethods[i]();
          if (decodedText) break; // 解码成功则退出重试
        } catch (err) {
          if (i === decodeMethods.length - 1) { // 最后一次重试失败才抛出错误
            throw new Error(`所有解码方案均失败（方案${i+1}）：${err.message}`);
          }
          console.warn(`解码方案${i+1}失败，重试下一种：`, err);
        }
      }

      return decodedText;
    }

    // 初始化解析逻辑
    function initParser() {
      const mdBase64 = getQueryParam('md');
      const contentEl = document.getElementById('markdownContent');
      const debugEl = document.getElementById('debugInfo');
      
      // 调试信息（方便排查问题）
      const debugInfo = [
        `原始md参数长度: ${mdBase64.length}`,
        `原始md参数前50字符: ${mdBase64.substring(0, 50)}...`,
        `URL长度: ${window.location.href.length}（建议≤2000）`
      ];
      debugEl.textContent = debugInfo.join('\n');
      debugEl.style.display = 'block';

      // 无参数提示
      if (!mdBase64) {
        contentEl.className = 'error';
        contentEl.innerHTML = `
          <h3>使用说明</h3>
          <p>请在URL后添加 GET 参数：?md=【Markdown内容的Base64编码】</p>
          <p>示例：${window.location.href.split('?')[0]}?md=5L2g5aW95rWL6K+V5pWF56ug</p>
          <p>提示：支持标准Base64和URL安全Base64（-/_替代+/）</p>
        `;
        return;
      }

      // 解析流程
      try {
        // 检查URL长度（避免浏览器限制）
        if (window.location.href.length > 2000) {
          console.warn('URL长度超过2000字符，可能被浏览器截断');
          contentEl.innerHTML += '<div style="color: #ffc107; padding: 10px; background: #fff3cd; border-radius: 4px; margin-top: 10px;">⚠️ 警告：URL长度过长，可能导致参数被截断，请缩短Markdown内容</div>';
        }

        const mdText = decodeSafeBase64(mdBase64);
        const html = marked.parse(mdText);
        contentEl.className = 'markdown-container';
        contentEl.innerHTML = html;

        // 追加调试信息（解码后的内容预览）
        debugInfo.push(`\n解码后Markdown前100字符: ${mdText.substring(0, 100)}...`);
        debugEl.textContent = debugInfo.join('\n');

      } catch (err) {
        contentEl.className = 'error';
        contentEl.innerHTML = `
          <h3>解析失败</h3>
          <p><strong>错误类型：</strong>${err.name}</p>
          <p><strong>错误信息：</strong>${err.message}</p>
          <p><strong>排查建议：</strong></p>
          <ul>
            <li>1. 检查Base64编码是否完整（无截断、无多余字符）</li>
            <li>2. 确认Markdown内容为UTF-8编码后再做Base64</li>
            <li>3. 避免URL长度超过2000字符（可分段/缩短内容）</li>
            <li>4. 推荐编码工具：<a href="https://www.base64encode.org/" target="_blank">Base64Encode.org</a>（选择UTF-8+URL安全）</li>
          </ul>
        `;
        console.error('解析异常详情:', err);
      }
    }

    // 页面加载后执行
    window.addEventListener('DOMContentLoaded', initParser);
  </script>
</body>
</html>
